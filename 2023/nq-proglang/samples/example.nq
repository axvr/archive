(ns uk.axvr.example
  "Namespace containing examples of Enqueue code."
  {org.enqueue.core            {:import :all}          ; Default in namespaces.
   org.enqueue.test            {:as test, :import #{deftest}}
   org.enqueue.string          {:as str}
   org.enqueue.time            {:as time}
   org.enqueue.logging         {:as log}
   org.enqueue.path            {:as path}
   org.enqueue.codec.json      {:as json}
   org.enqueue.codec.edn       {:as edn}
   org.enqueue.codec.msgpack   {:as msgpack}
   org.enqueue.codec.cbor      {:as cbor}
   org.enqueue.codec.xml       {:as xml}
   org.enqueue.codec.base64    {:as base64}
   org.enqueue.net             {:as net}  ; Ports and stuff.
   org.enqueue.net.dns         {:as dns}
   org.enqueue.net.tcp         {:as net.tcp}
   org.enqueue.net.amqp        {:as net.amqp}
   org.enqueue.net.zeromq      {:as zmq}
   org.enqueue.net.websocket   {:as websocket}
   org.enqueue.net.http.client {:as http.client}
   org.enqueue.net.http.server {:as http.server}
   org.enqueue.crypto.tls      {:as tls}
   org.enqueue.crypto.hash     {:as hash}
   uk.axvr.example.bar         {:alias bar}})

;; Commas are whitespace.
,

;; Booleans behave exactly like in Clojure.
true
false

;; Nil is nothing.
nil

;; Strings.
"Hello, world!"

;; Regular expressions.
#"^.+@.+$"

;; Characters.
\a
\u1234
\space
\\
\newline

;; Numbers.
1234   ; Integer.
1234.  ; Decimal.
1234.0 ; Decimal.
0x1234 ; Hex integer.
0b1234 ; Binary integer.
6r1234 ; Base 6 integer.
1,234  ; Commas inbetween numbers act as groupings?
-1234  ; Negative integer.
1/3    ; Ratio.

;; Keywords.
:foo
::foo
::bar/foo
:"foo bar"              ; Keywords containing special characters.
:"foo bar"/baz          ; Useful for interoping with data that has non-NQ keys.
:"foo\nbar"/"biz\nbaz"  ; Reader must be able to read all printer results.

;; Symbols.
'foo
'bar/foo
`foo
'|"foo\nbar biz"  ; Symbols containing special characters.
'foo/"bar"
'|"foo"/bar

;; Functions.
(fn [x] (+ 12 x))

;; Strings.
print
println
prn
pr
*pretty*
str
format

;; Maths functions.
inc
dec
+
-
*
/
=
asc?
desc?
strictly-asc?
strictly-desc?
pow
log
sqrt
root
decimal  ; Cast to decimal.
int      ; Cast to integer.
parse-int
parse-decimal
int?
decimal?
pos?
neg?
zero?
<<
>>
even?
odd?

;; Boolean functions.
bool   ; Cast to boolean.
some?  ; truthy -> true, falsy -> false.
bool?  ; true/false -> true
parse-bool  ; If bool: return, else if: try parse string as boolean.
true?
false?
not

;; UUIDs.
;; uuid-v1
;; uuid-v2
;; uuid-v3
uuid-v4
uuid-v5
;; uuid-v6
;; uuid-v7
;; uuid-v8
uuid.dns
uuid.url
uuid.oid
uuid.x.500dn
uuid?
parse-uuid
uuid.nil
#uuid nil
uuid-v4?  ;; Make sure given input was a UUIDv4
snowflake ;; ???
typeid    ;; ???

;; URIs.
net/uri?
net/parse-uri
#net/uri ""
net/uri
net/url
net/url?
net/parse-url
#net/url ""
net/uri->url
net/url->uri
net/urn?
net/parse-urn
#net/urn ""
net/urn

;; Domain name.
;; IDNA.

;; Email address.

;; Bindings.
let

;; Conditionals.
if
when
when-not
if-let
when-let
when-some
if-some
cond
case
cond->
cond->>
cond*   ; Like condp but with params other way around.

;; Time.
(time/now :monotonic true)
(time/range)  ; => {:min ..., :max ...}
(time/convert temporal :to :utc)
(time/convert temporal :to :tai)
(time/convert temporal :to :unix)

;; Log.
log/debug
log/info
log/warn
log/error
log/with-context

;; Base64
base64/encode
base64/decode
base64/url-encode
base64/url-decode

;; vim: ft=clojure :
